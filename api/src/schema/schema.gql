scalar Point
scalar DateTime
scalar PointInput

"""
User will also contain spaces[], comments[], answers[], questions[]
Drawback: Password is being stored as plain string. Not able to figure out JWT
"""
type User {
	_id: ID!
	name: String!
	email: String!
	password: String!
	spaces: [Space] @relationship(type: "READING_SPACE", direction: OUT)
	posts(first: Int = 0): [Post!]
		@cypher(
			statement: "MATCH (this)-[:WROTE]->(p:Post) ORDER BY p.updatedOn LIMIT $first RETURN p"
		)
	numPosts: Int
		@cypher(statement: "MATCH (this)-[:WROTE]->(p:Post) RETURN count(p)")
	answers(first: Int = 0): [Answer!]
		@cypher(
			statement: "MATCH (this)-[:WROTE]->(a:Answer) ORDER BY a.updatedOn LIMIT $first RETURN a"
		)
	numAnswers: Int
		@cypher(statement: "MATCH (this)-[:WROTE]->(a:Answer) RETURN count(a)")
	comments(first: Int = 0): [Comment!]
		@cypher(
			statement: "MATCH (this)-[:WROTE]->(c:Comment) ORDER BY c.updatedOn LIMIT $first RETURN c"
		)
	numComments: Int
		@cypher(statement: "MATCH (this)-[:WROTE]->(c:Comment) RETURN count(c)")
}

type Space {
	_id: ID!
	name: String!
	users: [User] @relationship(type: "READING_SPACE", direction: IN)
	posts: [Post] @relationship(type: "BELONGS_IN", direction: OUT)
}

type Post {
	_id: ID!
	title: String!
	text: String
	answers: [Answer!] @relationship(type: "ANSWERS", direction: OUT)
	updatedOn: DateTime
	createdOn: DateTime!
	spaces: [Space!] @relationship(type: "BELONGS_IN", direction: IN)
	postedBy: User! @relationship(type: "WROTE", direction: IN)
}

type Answer {
	_id: ID!
	text: String!
	updatedOn: DateTime
	votes: Int
	createdOn: DateTime!
	post: Post! @relationship(type: "ANSWERS", direction: IN)
	postedBy: User! @relationship(type: "WROTE", direction: IN)
}

type Comment {
	_id: ID!
	text: String!
	comments: [Comment!]
	updatedOn: DateTime
	createdOn: DateTime!
	postedBy: User! @relationship(type: "WROTE", direction: IN)
}

"""
createSpace: Only use sparingly for creating a new space if needed
changeUserSpace: Update spaces for this signed in user
publishPost: Create a new post
"""
type Mutation {
	createUser(
		name: String!
		email: String!
		password: String!
	): UserMutationResponse
	createSpace(name: String!): GenericMutationResponse
	changeUserSpaces(spaceIds: [String!]): UserMutationResponse
	publishPost(
		title: String!
		text: String
		spaceIds: [String!]
	): GenericMutationResponse
}

type Query {
	userCount: Int! @cypher(statement: "MATCH (u:User) RETURN COUNT(u)")
	signInUser(email: String!, password: String!): UserMutationResponse
	getUserSpaces: UserMutationResponse
	getSpaces: [Space]
		@cypher(
			statement: """
			MATCH (s: Space) RETURN s
			"""
		)
}

"""
Response for any mutation related to the user type
User: The user that has been created or updated

Rest of the fields complete from MutationResponse interface
"""
type UserMutationResponse implements MutationResponse {
	error: Error
	operation: String!
	code: String!
	status: String!
	user: [User]
	token: String
}

type GenericMutationResponse implements MutationResponse {
	error: Error
	operation: String!
	code: String!
	status: String!
	token: String
}

"""
User: The user that has been created or updated
Error: If any error occurred, this will contain a value

These values come from the Response interface
Code: Error code to denote exactly what happened
Operaton: What operation was being performed
Status: Denoting if the operation was completed or resulted in an error
"""
interface MutationResponse implements Response {
	error: Error
	operation: String!
	code: String!
	status: String!
	token: String
}

"""
Message: The user side message to display
Code: Error code to denote exactly what happened
Operaton: What operation was being performed
"""
type Error {
	message: String!
}

"""
Interface is used to return the responses for mutations
Code: Error code to denote exactly what happened
Operaton: What operation was being performed
Status: Denoting if the operation was completed or resulted in an error
"""
interface Response {
	operation: String!
	code: String!
	status: String!
}
