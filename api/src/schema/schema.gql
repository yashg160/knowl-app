scalar Point
scalar DateTime
scalar PointInput
scalar Integer

"""
User will also contain spaces[], comments[], answers[], questions[]
"""
type User {
  _id: ID!
  name: String!
  email: String!
  password: String!
  spaces: [Space] @relationship(type: "READING_SPACE", direction: OUT)
  posts(userId: String): [Post!]
    @cypher(
      statement: "MATCH (User {_id: $userId})-[:WROTE]->(p:Post) RETURN p ORDER BY p.updatedOn;"
    )
  answers(userId: String): [Answer!]
    @cypher(
      statement: "MATCH (User {_id: $userId})-[:WROTE]->(a:Answer)  RETURN a ORDER BY a.updatedOn"
    )
  comments(userId: String): [Comment!]
    @cypher(
      statement: "MATCH (User {_id: $userId})-[:WROTE]->(c:Comment) RETURN c ORDER BY c.updatedOn"
    )
  numPosts(userId: String): Int
    @cypher(
      statement: "MATCH (User {_id: $userId})-[:WROTE]->(p:Post) RETURN count(p);"
    )
  numAnswers(userId: String): Int
    @cypher(
      statement: "MATCH (User {_id: $userId})-[:WROTE]->(a:Answer) RETURN count(a.low);"
    )
  numComments(userId: String): Int
    @cypher(
      statement: "MATCH (User {_id: $userId})-[:WROTE]->(c:Comment) RETURN count(c.low);"
    )
}

type Space {
  _id: ID!
  name: String!
  users: [User] @relationship(type: "READING_SPACE", direction: IN)
  posts: [Post] @relationship(type: "BELONGS_IN", direction: OUT)
}

type Post {
  _id: ID!
  title: String!
  text: String
  votes: Int
  label: String!
  answers: [Answer!] @relationship(type: "ANSWERS", direction: OUT)
  updatedOn: DateTime
  createdOn: DateTime!
  spaces: [Space!] @relationship(type: "BELONGS_IN", direction: IN)
  postedBy: User! @relationship(type: "WROTE", direction: IN)
}

type Answer {
  _id: ID!
  votes: Int
  label: String!
  text: String!
  updatedOn: DateTime
  createdOn: DateTime!
  post: Post! @relationship(type: "ANSWERS", direction: IN)
  postedBy: User! @relationship(type: "WROTE", direction: IN)
}

type Comment {
  _id: ID!
  text: String!
  comments: [Comment!]
  updatedOn: DateTime
  createdOn: DateTime!
  postedBy: User! @relationship(type: "WROTE", direction: IN)
}

"""
createSpace: Only use sparingly for creating a new space if needed
changeUserSpace: Update spaces for this signed in user
publishPost: Create a new post
"""
type Mutation {
  createUser(
    name: String!
    email: String!
    password: String!
  ): UserMutationResponse
  createSpace(name: String!): GenericMutationResponse
  changeUserSpaces(spaceIds: [String!]): UserMutationResponse
  publishPost(
    title: String!
    text: String
    spaceIds: [String!]
  ): GenericMutationResponse
  createAnswer(questionId: String!, text: String!): GenericMutationResponse
  updateProfile(name: String!, email: String!): UserMutationResponse
  updateQuestion(
    title: String!
    text: String!
    questionId: ID!
  ): GenericMutationResponse
}

type Query {
  getUserRecommendations: UserSuggestionsResponse
  getQuestionAnswers(questionId: String!): [Answer]
  userCount: Int! @cypher(statement: "MATCH (u:User) RETURN COUNT(u)")
  signInUser(email: String!, password: String!): UserMutationResponse
  getUserSpaces: UserMutationResponse
  getSpaces: [Space]
    @cypher(
      statement: """
      MATCH (s: Space) RETURN s
      """
    )
  getUserProfile(userId: ID!): User
}

type UserProfileResponse implements Response {
  profile: User
  error: Error
  operation: String!
  code: String!
  status: String!
}

type UserSuggestionsResponse implements Response {
  questions: [PostResponse]!
  error: Error
  operation: String!
  code: String!
  status: String!
}

type PostResponse {
  _id: String!
  title: String!
  text: String
  votes: Int
  author: PostAuthorResponse
  createdOn: DateTime
  updatedOn: DateTime
  answerCount: Int
  spaces: [String]
}

type PostAuthorResponse {
  name: String!
  _id: ID!
}

"""
Response for any mutation related to the user type
User: The user that has been created or updated

Rest of the fields complete from MutationResponse interface
"""
type UserMutationResponse implements MutationResponse {
  error: Error
  operation: String!
  code: String!
  status: String!
  user: [User]
  token: String
}

type GenericMutationResponse implements MutationResponse {
  error: Error
  operation: String!
  code: String!
  status: String!
  token: String
}

"""
User: The user that has been created or updated
Error: If any error occurred, this will contain a value

These values come from the Response interface
Code: Error code to denote exactly what happened
Operaton: What operation was being performed
Status: Denoting if the operation was completed or resulted in an error
"""
interface MutationResponse implements Response {
  error: Error
  operation: String!
  code: String!
  status: String!
  token: String
}

"""
Message: The user side message to display
Code: Error code to denote exactly what happened
Operaton: What operation was being performed
"""
type Error {
  message: String!
}

"""
Interface is used to return the responses for mutations
Code: Error code to denote exactly what happened
Operaton: What operation was being performed
Status: Denoting if the operation was completed or resulted in an error
"""
interface Response {
  operation: String!
  code: String!
  status: String!
}
